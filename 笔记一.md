# jMetal 学习笔记

## The Algorithm:
**Algorithm是所有优化算法的模板，只定义了两个接口方法run()和getResult()。run()是算法的运行入口，getResult()用于返回结果集，一般就是算法得到的Pareto集**
````java
    public interface Algorithm<Result> extends Runnable{
        void run();
        Result getResult();
        }
````

自己的算法类需要继承AbstractGeneticAlgorithm。AbstarctGeneticAlgorithm继承AbstractEvolutionaryAlgorithm。
````java
package org.uma.jmetal.algorithm.impl;

import org.uma.jmetal.operator.CrossoverOperator;
import org.uma.jmetal.operator.MutationOperator;
import org.uma.jmetal.operator.SelectionOperator;
import org.uma.jmetal.problem.Problem;
import org.uma.jmetal.util.JMetalException;

import java.util.ArrayList;
import java.util.List;

/**
 * Abstract class representing a genetic algorithm
 *
 * @author Antonio J. Nebro <antonio@lcc.uma.es>
 */
@SuppressWarnings("serial")
public abstract class AbstractGeneticAlgorithm<S, Result> extends AbstractEvolutionaryAlgorithm<S, Result> {
  protected int maxPopulationSize ;
  protected SelectionOperator<List<S>, S> selectionOperator ;
  protected CrossoverOperator<S> crossoverOperator ;
  protected MutationOperator<S> mutationOperator ;

}

````
类的成员方法包括
- (setters&getters)设置最大种群,获得最大种群, 获得选择算子,获得交叉算子,获得遗传算子
- 构造函数传入要解决的问题
- 初始化种群
- 交配
- 繁衍

**各个具体遗传算法继承AbstractGeneticAlgorithm，重载少数方法，如官方NSGAII,在构造函数里需要提供算法其他组件**

1. **Problem：要解决的问题类**
2. **CrossoverOperator：交叉算子**
3. **MutationOperator：变异算子**
4. **SelectionOperator：matepool的选择算子**
5. **Evaluator：优化函数评估算子**
6. **populationSIze：种群大小**
7. **maxEvations：最大评估次数（作为停止条件）**

**如果需要自己定义选择，交叉，变异操作，可以实现对应接口，然后将这些类作为组件提供给具体地Algorithm**
````java
public class NSGAII<S extends Solution<?>> extends AbstractGeneticAlgorithm<S, List<S>> {
    public NSGAII(Problem<S> problem, int maxEvaluations, int populationSize,
      CrossoverOperator<S> crossoverOperator, MutationOperator<S> mutationOperator,
      SelectionOperator<List<S>, S> selectionOperator, SolutionListEvaluator<S> evaluator) {
    super(problem);
    this.maxEvaluations = maxEvaluations;
    setMaxPopulationSize(populationSize); ;

    this.crossoverOperator = crossoverOperator;
    this.mutationOperator = mutationOperator;
    this.selectionOperator = selectionOperator;

    this.evaluator = evaluator;
  }
} 
````

### The Solution  
[官方solution定义](https://github.com/jMetal/jMetalDocumentation/blob/master/solution.md)
_In jMetal 5 there is not any class to represent the concept of population. Instead, a Java List of Solution objects is used._

**注意构造函数中的泛型参数S extends Soluiton。Solution是个体定义的接口，每个Solution就是种群中一个个体，Solution需要做的是定义染色体编码方案，记录优化函数值，约束目标值，其他信息等，默认提供了BinarySoluiton、DoubleSolution、IntegerSoluiton等。同样的，如果需要定义新的Solution，你需要继承的是AbstractGenericSolution这个类**
````java
public abstract class AbstractGenericSolution<T, P extends Problem<?>> implements Solution<T> {
  private double[] objectives;
  private List<T> variables;
  protected P problem ;
  protected Map<Object, Object> attributes ;
  protected final JMetalRandom randomGenerator ;
    /**
   * Constructor
   */
  protected AbstractGenericSolution(P problem) {
    this.problem = problem ;
    attributes = new HashMap<>() ;
    randomGenerator = JMetalRandom.getInstance() ;

    objectives = new double[problem.getNumberOfObjectives()] ;
    variables = new ArrayList<>(problem.getNumberOfVariables()) ;
    for (int i = 0; i < problem.getNumberOfVariables(); i++) {
      variables.add(i, null) ;
    }
  }
  .....
}
````


### The Problem

**problem定义了需要解决的问题，比如有几个决策变量，几个优化函数。其中每个个体的优化函数的计算过程就是由Problem.evluate()来实现的，这也是Problem类最重要的部分。举个例子：ZDT1，ZDT是一个经典的多目标优化测试函数集，定义如下：**

    (两个优化函数，30个决策变量)

````java
public class ZDT1 extends AbstractDoubleProblem {
    /**
   * Creates a new instance of problem ZDT1.
   *
   * @param numberOfVariables Number of variables.
   */
  public ZDT1(Integer numberOfVariables) {
    setNumberOfVariables(numberOfVariables);
    setNumberOfObjectives(2);
    setName("ZDT1");

    List<Double> lowerLimit = new ArrayList<>(getNumberOfVariables()) ;
    List<Double> upperLimit = new ArrayList<>(getNumberOfVariables()) ;

    for (int i = 0; i < getNumberOfVariables(); i++) {
      lowerLimit.add(0.0);
      upperLimit.add(1.0);
    }

    setLowerLimit(lowerLimit);
    setUpperLimit(upperLimit);
  }
}
````

其中AbstractDoubleProblem 是通用的DoubleProblem模板，如果你的问题是Double类型的
实现这类就可以了。evaluate()由AbstractEvolutionaryAlgorithm.evaluatePopulation
()调用，在你的算法中，如果需要自己定义优化函数，就可以在evaluate()中进行定义。


## The Operator

**交叉、变异和选择算子都是Operator接口的实现，这里用SimpleRandomMutation这个类来说明，SimpleRandomMutation实现变量在定义域内变异**
````java
public class SimpleRandomMutation implements MutationOperator<DoubleSolution> {  
  private double mutationProbability ;  
  private RandomGenerator<Double> randomGenerator ;  
    
  ...  
/** Execute() method */  
    @Override  
  public DoubleSolution execute(DoubleSolution solution) throws JMetalException {  
    if (null == solution) {  
      throw new JMetalException("Null parameter") ;  
    }  
  
    doMutation(mutationProbability, solution) ;  
      
    return solution;  
  }  
  
  /** Implements the mutation operation */  
    private void doMutation(double probability, DoubleSolution solution) {  
    for (int i = 0; i < solution.getNumberOfVariables(); i++) {  
      if (randomGenerator.getRandomValue() <= probability) {  
        Double value = solution.getLowerBound(i) +  
                ((solution.getUpperBound(i) - solution.getLowerBound(i)) * randomGenerator.getRandomValue()) ;  
          
        solution.setVariableValue(i, value) ;  
      }  
    }  
    }  
}  
````

注意在DoubleSolution里面设定好决策变量的定义域大小，如果每个决策变量的定义域不一样的话可以用ArrayDoubleSolution（extends DoubleSolution）这个类。
交叉算子和变异算子类似

### The Result(结果集)
**通过调用Algorithem.getResult()来得到结果集的，对大部分算法来说也就是Pareto集。NSGA-II中的实现代码如下：**
```java
    @Override public List<S> getResult() {  
   return getNonDominatedSolutions(getPopulation());  
 }  
protected List<S> getNonDominatedSolutions(List<S> solutionList) {  
   return SolutionListUtils.getNondominatedSolutions(solutionList);  
 }  
```

SolutionListUtils类提供了对种群的操作，如对种群按支配关系排序，得到最好最差解等。

---
##### 总结

1.**实现AbstractGenericSolution，在具体类里面定义编码方案，定义决策变量，定义优化目标函数储存方法；**

2.**实现AbstractDoubleProblem，在具体类中定义需要解决的问题，overide evaluate()来定义优化函数；**

3.**实现各个Operator：选择、交叉、变异；**

4.**实现AbstractEvolutionaryAlgorithm，Operator提供给具体的Algorithm类，并设定参数；**

5.**调用run()跑算法，调用getResult()得到结果集**
